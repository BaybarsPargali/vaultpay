// src/lib/cosigner/compliant-transfer.ts
// ============================================================================
// COMPLIANT CONFIDENTIAL TRANSFER SERVICE
// ============================================================================
//
// This combines the CLI Bridge (for ZK proof generation) with
// Range Protocol compliance checking.
//
// FLOW:
// 1. Check compliance via Range BEFORE executing transfer
// 2. If compliant, execute confidential transfer via CLI
// 3. Amount is NEVER visible on-chain (ElGamal encrypted)
//
// WHY THIS APPROACH:
// - Token-2022 CT requires Bulletproof ZK proofs
// - These proofs can ONLY be generated by the Rust CLI
// - The CLI executes atomically (no separate "build" step)
// - So we validate compliance FIRST, then execute
//
// PRIVACY GUARANTEE:
// - Amount is encrypted by Token-2022 (ElGamal + ZK proofs)
// - Compliance check only sees recipient address
// - On-chain: only ciphertext visible, never plaintext amount
//
// ============================================================================

import { PublicKey } from '@solana/web3.js';
import { CTCliBridge, CLIResult, getCliBridge } from '@/lib/confidential/cli-bridge';
import { rangeClient } from '@/lib/range/client';
import { CONFIDENTIAL_MINT } from '@/lib/cosigner';
import prisma from '@/lib/db/prisma';
import { logger } from '@/lib/logger';

// ============================================================================
// TYPES
// ============================================================================

export interface ComplianceCheckResult {
  approved: boolean;
  recipientAddress: string;
  riskScore: number;
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  reason?: string;
  checkedAt: Date;
}

export interface CompliantTransferParams {
  /** Sender's wallet address */
  senderWallet: string;
  /** Recipient's wallet address */
  recipientWallet: string;
  /** Amount to transfer (in tokens, not smallest unit) */
  amount: number;
  /** Organization ID for audit trail */
  organizationId: string;
  /** Optional payment ID for database update */
  paymentId?: string;
  /** Optional keypair path for CLI */
  keypairPath?: string;
}

export interface CompliantTransferResult {
  success: boolean;
  /** Transaction signature (if successful) */
  txSignature?: string;
  /** Compliance check result */
  compliance: ComplianceCheckResult;
  /** Error message (if failed) */
  error?: string;
  /** CLI output for debugging */
  cliOutput?: string;
}

// ============================================================================
// CONSTANTS
// ============================================================================

const COMPLIANCE_RISK_THRESHOLD = 70;

// ============================================================================
// COMPLIANT TRANSFER SERVICE
// ============================================================================

/**
 * Execute a compliant confidential transfer
 * 
 * This is the main function for VaultPay private payments.
 * 
 * SECURITY MODEL:
 * 1. Compliance is checked BEFORE any funds move
 * 2. If compliance fails, no transfer occurs
 * 3. If compliance passes, confidential transfer executes
 * 4. Amount is encrypted on-chain (ElGamal)
 * 
 * @example
 * ```typescript
 * const result = await executeCompliantTransfer({
 *   senderWallet: 'ABC...',
 *   recipientWallet: 'XYZ...',
 *   amount: 100,
 *   organizationId: 'org-123',
 * });
 * 
 * if (result.success) {
 *   console.log('Private payment sent:', result.txSignature);
 *   // Amount is ENCRYPTED on-chain!
 * }
 * ```
 */
export async function executeCompliantTransfer(
  params: CompliantTransferParams
): Promise<CompliantTransferResult> {
  const { 
    senderWallet, 
    recipientWallet, 
    amount, 
    organizationId, 
    paymentId,
    keypairPath 
  } = params;

  logger.info(
    { senderWallet, recipientWallet, amount, organizationId, paymentId },
    '[CompliantTransfer] Starting compliant confidential transfer'
  );

  // =========================================================================
  // STEP 1: Compliance Check (BEFORE any funds move)
  // =========================================================================
  
  const compliance = await checkCompliance(recipientWallet);
  
  logger.info(
    { 
      recipientWallet, 
      approved: compliance.approved, 
      riskScore: compliance.riskScore 
    },
    '[CompliantTransfer] Compliance check result'
  );

  if (!compliance.approved) {
    // Update payment status if paymentId provided
    if (paymentId) {
      await prisma.payment.update({
        where: { id: paymentId },
        data: {
          status: 'rejected',
          errorMessage: compliance.reason || 'Compliance check failed',
        },
      });
    }

    logger.warn(
      { recipientWallet, reason: compliance.reason },
      '[CompliantTransfer] Transfer rejected due to compliance'
    );

    return {
      success: false,
      compliance,
      error: compliance.reason || 'Compliance check failed',
    };
  }

  // =========================================================================
  // STEP 2: Update payment to processing
  // =========================================================================
  
  if (paymentId) {
    await prisma.payment.update({
      where: { id: paymentId },
      data: { status: 'processing' },
    });
  }

  // =========================================================================
  // STEP 3: Execute Confidential Transfer via CLI
  // =========================================================================
  
  logger.info(
    { amount, recipientWallet },
    '[CompliantTransfer] Executing confidential transfer via CLI'
  );

  const bridge = getCliBridge({ keypairPath });
  
  // Check if CLI is available
  const cliAvailable = await bridge.checkCLIAvailable();
  if (!cliAvailable) {
    const error = 'CLI bridge not available. Install spl-token CLI.';
    
    if (paymentId) {
      await prisma.payment.update({
        where: { id: paymentId },
        data: {
          status: 'failed',
          errorMessage: error,
        },
      });
    }

    return {
      success: false,
      compliance,
      error,
    };
  }

  // Execute the confidential transfer
  // Amount is encrypted by Token-2022 (ElGamal + ZK proofs)
  // Include memo for reconciliation (memo is visible, amount is NOT)
  const memo = paymentId ? `VaultPay:${paymentId}` : undefined;
  
  const transferResult = await bridge.transfer(
    CONFIDENTIAL_MINT.toBase58(),
    amount,
    recipientWallet,
    memo
  );

  if (!transferResult.success) {
    const error = transferResult.error || 'Confidential transfer failed';
    
    if (paymentId) {
      await prisma.payment.update({
        where: { id: paymentId },
        data: {
          status: 'failed',
          errorMessage: error,
        },
      });
    }

    logger.error(
      { error, cliOutput: transferResult.output },
      '[CompliantTransfer] CLI transfer failed'
    );

    return {
      success: false,
      compliance,
      error,
      cliOutput: transferResult.output,
    };
  }

  // =========================================================================
  // STEP 4: Update payment status
  // =========================================================================
  
  const txSignature = transferResult.signature;
  
  if (paymentId) {
    await prisma.payment.update({
      where: { id: paymentId },
      data: {
        status: 'completed',
        txSignature: txSignature || undefined,
        executedAt: new Date(),
      },
    });
  }

  logger.info(
    { txSignature, recipientWallet, amount },
    '[CompliantTransfer] Confidential transfer completed successfully'
  );

  return {
    success: true,
    txSignature,
    compliance,
    cliOutput: transferResult.output,
  };
}

/**
 * Check compliance for a recipient address
 */
async function checkCompliance(recipientAddress: string): Promise<ComplianceCheckResult> {
  try {
    const rangeResult = await rangeClient.screenAddress(recipientAddress);
    
    const riskScore = rangeResult.riskScore || 0;
    const riskLevel = getRiskLevel(riskScore);
    const approved = riskScore <= COMPLIANCE_RISK_THRESHOLD;

    return {
      approved,
      recipientAddress,
      riskScore,
      riskLevel,
      reason: approved 
        ? 'Compliance check passed' 
        : `Risk score ${riskScore} exceeds threshold ${COMPLIANCE_RISK_THRESHOLD}`,
      checkedAt: new Date(),
    };

  } catch (error) {
    logger.error({ error, recipientAddress }, '[Compliance] Check failed');
    
    // Fail-safe: reject if compliance check fails
    return {
      approved: false,
      recipientAddress,
      riskScore: 100,
      riskLevel: 'critical',
      reason: `Compliance check error: ${error instanceof Error ? error.message : 'Unknown error'}`,
      checkedAt: new Date(),
    };
  }
}

/**
 * Convert risk score to risk level
 */
function getRiskLevel(score: number): 'low' | 'medium' | 'high' | 'critical' {
  if (score <= 25) return 'low';
  if (score <= 50) return 'medium';
  if (score <= 75) return 'high';
  return 'critical';
}

/**
 * Check if compliant transfers are available
 * (Requires CLI bridge)
 */
export async function isCompliantTransferAvailable(): Promise<{
  available: boolean;
  cliAvailable: boolean;
  mint: string;
}> {
  const bridge = getCliBridge();
  const cliAvailable = await bridge.checkCLIAvailable();
  
  return {
    available: cliAvailable,
    cliAvailable,
    mint: CONFIDENTIAL_MINT.toBase58(),
  };
}
